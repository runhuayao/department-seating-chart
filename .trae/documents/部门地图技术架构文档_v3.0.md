# 部门地图系统技术架构文档 v4.0 - Redis缓存优化版

## 1. 架构设计

### 1.1 整体架构图

```mermaid
graph TD
    A[用户浏览器] --> B[Nginx反向代理]
    B --> C[React前端应用]
    B --> D[Express后端API]
    
    C --> E[WebSocket客户端]
    E --> F[WebSocket服务器]
    F --> D
    
    D --> G[PostgreSQL数据库]
    D --> H[Redis缓存集群]
    D --> I[搜索缓存系统]
    
    H --> J[Redis主节点]
    H --> K[Redis从节点1]
    H --> L[Redis从节点2]
    
    subgraph "前端层 (Client Layer)"
        C
        E
    end
    
    subgraph "网关层 (Gateway Layer)"
        B
    end
    
    subgraph "应用层 (Application Layer)"
        D
        F
    end
    
    subgraph "数据层 (Data Layer)"
        G
        subgraph "Redis缓存层"
            J
            K
            L
        end
        I
    end
```

### 1.2 Redis缓存架构优化

```mermaid
graph TD
    A[前端请求] --> B{缓存检查}
    B -->|命中| C[Redis缓存]
    B -->|未命中| D[PostgreSQL数据库]
    
    C --> E[缓存数据返回]
    D --> F[数据库查询]
    F --> G[更新Redis缓存]
    G --> H[返回数据]
    
    subgraph "Redis缓存策略"
        I[工位信息缓存]
        J[部门地图缓存]
        K[员工状态缓存]
        L[搜索结果缓存]
        M[会话缓存]
    end
    
    subgraph "缓存更新机制"
        N[实时更新]
        O[定时刷新]
        P[手动失效]
        Q[LRU淘汰]
    end
    
    C --> I
    C --> J
    C --> K
    C --> L
    C --> M
```

### 1.3 PostgreSQL替代SQLite架构升级

```mermaid
graph TD
    A[旧架构: SQLite] --> B[数据迁移脚本]
    B --> C[新架构: PostgreSQL]
    
    subgraph "SQLite限制"
        D[单文件数据库]
        E[并发限制]
        F[功能受限]
    end
    
    subgraph "PostgreSQL优势"
        G[分布式支持]
        H[高并发处理]
        I[全文搜索]
        J[JSON支持]
        K[复杂查询]
    end
    
    C --> G
    C --> H
    C --> I
    C --> J
    C --> K
```

## 2. 技术描述

### 2.1 核心技术栈

- **前端**: React@18 + TypeScript@5 + Vite@5 + TailwindCSS@3
- **状态管理**: Zustand@4 + React Query@4
- **地图渲染**: D3.js@7 + SVG + Canvas (混合渲染)
- **后端**: Express@4 + TypeScript@5 + Node.js@18
- **数据库**: PostgreSQL@15 (主数据存储)
- **缓存系统**: Redis@7 (分布式缓存) + ioredis@5 (Redis客户端)
- **实时通信**: Socket.io@4 + WebSocket
- **认证**: JWT + bcrypt + Passport.js
- **部署**: Docker + Docker Compose + Nginx + Redis Cluster

### 2.2 Redis缓存优化技术

- **缓存架构**: Redis主从复制 + 哨兵模式 + 集群分片
- **缓存策略**: 多层缓存 (浏览器 → Redis → PostgreSQL)
- **数据结构**: Hash、Set、ZSet、String、List混合使用
- **缓存模式**: Cache-Aside + Write-Through + Write-Behind
- **失效策略**: TTL过期 + LRU淘汰 + 手动失效
- **数据压缩**: Redis压缩 + Gzip压缩 + JSON优化
- **增量更新**: WebSocket差量推送 + Redis发布订阅
- **预加载**: 智能预取相邻部门数据 + 热点数据预热
- **CDN**: 静态资源分发网络

### 2.3 Redis缓存数据结构设计

#### 2.3.1 工位信息缓存
```redis
# 工位基础信息 (Hash)
HSET workstation:E01 id "1" code "E01" x "100" y "100" status "occupied"
HSET workstation:E01 employee_id "1001" employee_name "张三" department "技术部"
EXPIRE workstation:E01 3600  # 1小时过期

# 部门工位列表 (Set)
SADD department:tech:workstations "E01" "E02" "E03" "E04" "E05" "E06"
EXPIRE department:tech:workstations 7200  # 2小时过期

# 工位状态索引 (ZSet - 按更新时间排序)
ZADD workstation:status:online 1703001234 "E01" 1703001235 "E03" 1703001236 "E05"
ZADD workstation:status:offline 1703001240 "E02"
ZADD workstation:status:available 1703001250 "E04" 1703001260 "E06"
```

#### 2.3.2 部门地图缓存
```redis
# 部门地图配置 (Hash)
HSET department:tech:map name "技术部" floor "3F" capacity "50"
HSET department:tech:map map_config '{"color":"#3B82F6","layout":"grid"}'
HSET department:tech:map stats '{"total":6,"occupied":4,"online":3}'
EXPIRE department:tech:map 1800  # 30分钟过期

# 部门员工在线状态 (Hash)
HMSET department:tech:presence 1001 "online" 1002 "offline" 1003 "online" 1004 "away"
EXPIRE department:tech:presence 300  # 5分钟过期
```

#### 2.3.3 搜索结果缓存
```redis
# 搜索结果缓存 (String - JSON)
SET search:"张三":tech '[{"id":1001,"name":"张三","workstation":"E01"}]'
EXPIRE search:"张三":tech 600  # 10分钟过期

# 热门搜索词 (ZSet)
ZINCRBY search:popular 1 "张三"
ZINCRBY search:popular 1 "技术部"
```

### 2.4 PostgreSQL特性应用

- **全文搜索**: GIN索引 + 中文分词
- **JSON支持**: 工位配置和元数据存储
- **并发控制**: 行级锁 + 事务隔离
- **分区表**: 历史数据按时间分区
- **连接池**: pgBouncer连接池管理

## 3. Redis缓存策略与性能优化

### 3.1 缓存更新策略

#### 3.1.1 实时数据更新流程
```mermaid
sequenceDiagram
    participant C as 客户端
    participant A as API服务
    participant R as Redis
    participant P as PostgreSQL
    participant W as WebSocket
    
    C->>A: 更新工位状态
    A->>P: 写入数据库
    P-->>A: 确认写入
    A->>R: 更新缓存
    A->>W: 发布更新事件
    W-->>C: 推送实时更新
    A-->>C: 返回成功响应
    
    Note over R: 缓存失效策略
    R->>R: 删除相关缓存键
    R->>R: 更新统计数据
```

#### 3.1.2 缓存失效机制
```typescript
// 缓存失效策略实现
class CacheInvalidationService {
  // 工位状态变更时的缓存失效
  async invalidateWorkstationCache(workstationId: string, departmentId: string) {
    const pipeline = redis.pipeline();
    
    // 删除工位详细信息缓存
    pipeline.del(`workstation:${workstationId}`);
    
    // 删除部门地图缓存
    pipeline.del(`department:${departmentId}:map`);
    
    // 删除部门在线状态缓存
    pipeline.del(`department:${departmentId}:presence`);
    
    // 删除相关搜索缓存
    const searchKeys = await redis.keys(`search:*:${departmentId}`);
    if (searchKeys.length > 0) {
      pipeline.del(...searchKeys);
    }
    
    await pipeline.exec();
  }
  
  // 员工状态变更时的缓存失效
  async invalidateEmployeeCache(employeeId: string) {
    const pipeline = redis.pipeline();
    
    // 删除员工相关的工位缓存
    const workstationKeys = await redis.keys(`workstation:*`);
    for (const key of workstationKeys) {
      const empId = await redis.hget(key, 'employee_id');
      if (empId === employeeId.toString()) {
        pipeline.del(key);
      }
    }
    
    await pipeline.exec();
  }
}
```

### 3.2 性能优化分析

#### 3.2.1 缓存命中率优化
```typescript
// 缓存预热策略
class CacheWarmupService {
  async warmupDepartmentData(departmentId: string) {
    // 预加载部门地图数据
    const mapData = await this.loadDepartmentMap(departmentId);
    await redis.hset(`department:${departmentId}:map`, mapData);
    await redis.expire(`department:${departmentId}:map`, 1800);
    
    // 预加载工位信息
    const workstations = await this.loadWorkstations(departmentId);
    const pipeline = redis.pipeline();
    
    workstations.forEach(ws => {
      pipeline.hset(`workstation:${ws.code}`, {
        id: ws.id,
        code: ws.code,
        x: ws.x_coordinate,
        y: ws.y_coordinate,
        status: ws.status,
        employee_id: ws.employee?.id || '',
        employee_name: ws.employee?.name || '',
        department: departmentId
      });
      pipeline.expire(`workstation:${ws.code}`, 3600);
    });
    
    await pipeline.exec();
  }
}
```

#### 3.2.2 性能指标对比
| 指标 | 无缓存 | 内存缓存 | Redis缓存 | 性能提升 |
|------|--------|----------|-----------|----------|
| 工位信息查询 | 50-100ms | 5-10ms | 8-15ms | 70-85% |
| 部门地图加载 | 200-500ms | 20-50ms | 25-60ms | 80-90% |
| 员工搜索 | 100-300ms | 15-30ms | 20-40ms | 75-85% |
| 并发处理能力 | 100 QPS | 500 QPS | 2000+ QPS | 20倍+ |
| 内存使用 | 数据库连接 | 应用内存 | 独立Redis | 分离优化 |

### 3.3 与现有内存缓存的迁移方案

#### 3.3.1 渐进式迁移策略
```mermaid
graph TD
    A[当前内存缓存] --> B{迁移阶段}
    B -->|阶段1| C[双写模式]
    B -->|阶段2| D[读写分离]
    B -->|阶段3| E[完全迁移]
    
    C --> F[内存缓存 + Redis缓存]
    D --> G[Redis读取 + 内存写入]
    E --> H[纯Redis缓存]
    
    subgraph "迁移验证"
        I[数据一致性检查]
        J[性能对比测试]
        K[回滚机制准备]
    end
```

#### 3.3.2 迁移实现代码
```typescript
// 缓存迁移服务
class CacheMigrationService {
  private useRedis = process.env.USE_REDIS_CACHE === 'true';
  private dualWrite = process.env.DUAL_WRITE_CACHE === 'true';
  
  async get(key: string): Promise<any> {
    if (this.useRedis) {
      // 优先从Redis读取
      const redisData = await redis.get(key);
      if (redisData) {
        return JSON.parse(redisData);
      }
      
      // Redis未命中，尝试内存缓存
      const memoryData = memoryCache.get(key);
      if (memoryData && this.dualWrite) {
        // 回写到Redis
        await redis.setex(key, 3600, JSON.stringify(memoryData));
      }
      return memoryData;
    }
    
    // 使用内存缓存
    return memoryCache.get(key);
  }
  
  async set(key: string, value: any, ttl: number = 3600): Promise<void> {
    if (this.dualWrite) {
      // 双写模式：同时写入内存和Redis
      await Promise.all([
        memoryCache.set(key, value, ttl),
        redis.setex(key, ttl, JSON.stringify(value))
      ]);
    } else if (this.useRedis) {
      // 仅写入Redis
      await redis.setex(key, ttl, JSON.stringify(value));
    } else {
      // 仅写入内存
      memoryCache.set(key, value, ttl);
    }
  }
}
```

## 4. 路由定义

### 4.1 前端路由

| 路由 | 组件 | 功能描述 |
|------|------|----------|
| / | HomePage | 首页重定向到登录或地图 |
| /login | LoginPage | 用户登录和注册 |
| /map/:department? | MapPage | 部门地图主页面 |
| /search | SearchPage | 人员搜索和定位 |
| /workstation | WorkstationPage | 工位管理页面 |
| /profile | ProfilePage | 个人中心页面 |
| /admin | AdminPage | 系统管理页面 |
| /admin/users | UserManagePage | 用户管理 |
| /admin/departments | DepartmentManagePage | 部门管理 |
| /admin/monitor | MonitorPage | 系统监控 |

### 4.2 API路由结构

```
/api/v1/
├── auth/
│   ├── POST /login
│   ├── POST /logout
│   ├── POST /refresh
│   └── GET /profile
├── departments/
│   ├── GET /
│   ├── GET /:id
│   ├── GET /:id/map
│   └── GET /:id/workstations
├── employees/
│   ├── GET /
│   ├── GET /:id
│   ├── PUT /:id
│   └── GET /search
├── workstations/
│   ├── GET /
│   ├── GET /:id
│   ├── PUT /:id/assign
│   └── PUT /:id/status
├── presence/
│   ├── POST /heartbeat
│   ├── GET /status/:department
│   └── GET /history/:employee
├── cache/
│   ├── POST /refresh
│   ├── DELETE /clear
│   ├── GET /stats
│   └── POST /warmup
└── admin/
    ├── GET /stats
    ├── POST /cache/refresh
    └── GET /health
```



## 5. API定义

### 5.1 Redis缓存管理API

#### 缓存刷新
```
POST /api/v1/cache/refresh
```

**请求参数:**
| 参数名 | 类型 | 必填 | 描述 |
|--------|------|------|------|
| type | string | false | 缓存类型 (workstation/department/search/all) |
| department_id | string | false | 部门ID (仅刷新特定部门缓存) |

**响应数据:**
| 字段名 | 类型 | 描述 |
|--------|------|------|
| success | boolean | 刷新是否成功 |
| refreshed_keys | number | 刷新的缓存键数量 |
| cache_stats | object | 缓存统计信息 |

#### 缓存统计
```
GET /api/v1/cache/stats
```

**响应数据:**
| 字段名 | 类型 | 描述 |
|--------|------|------|
| hit_rate | number | 缓存命中率 |
| total_keys | number | 总缓存键数量 |
| memory_usage | string | 内存使用量 |
| connected_clients | number | 连接客户端数 |

#### 缓存预热
```
POST /api/v1/cache/warmup
```

**请求参数:**
| 参数名 | 类型 | 必填 | 描述 |
|--------|------|------|------|
| department_ids | array | false | 需要预热的部门ID列表 |
| include_search | boolean | false | 是否预热搜索缓存 |

### 5.2 认证相关API

#### 用户登录
```
POST /api/v1/auth/login
```

**请求参数:**
| 参数名 | 类型 | 必填 | 描述 |
|--------|------|------|------|
| email | string | true | 用户邮箱 |
| password | string | true | 用户密码 |
| remember | boolean | false | 记住登录状态 |

**响应数据:**
| 字段名 | 类型 | 描述 |
|--------|------|------|
| success | boolean | 请求是否成功 |
| token | string | JWT访问令牌 |
| user | object | 用户基本信息 |
| expires | number | 令牌过期时间戳 |

**请求示例:**
```json
{
  "email": "zhang.san@company.com",
  "password": "password123",
  "remember": true
}
```

**响应示例:**
```json
{
  "success": true,
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "user": {
    "id": 1,
    "name": "张三",
    "email": "zhang.san@company.com",
    "role": "employee",
    "department": "技术部"
  },
  "expires": 1704067200000
}
```

### 4.2 搜索相关API

#### 员工搜索
```
GET /api/v1/employees/search
```

**查询参数:**
| 参数名 | 类型 | 必填 | 描述 |
|--------|------|------|------|
| q | string | true | 搜索关键词 |
| department | string | false | 部门筛选 |
| limit | number | false | 结果数量限制 (默认20) |
| offset | number | false | 分页偏移量 (默认0) |

**响应数据:**
| 字段名 | 类型 | 描述 |
|--------|------|------|
| success | boolean | 请求是否成功 |
| data | array | 搜索结果列表 |
| total | number | 总结果数量 |
| cached | boolean | 是否来自缓存 |

### 4.3 实时状态API

#### 心跳更新
```
POST /api/v1/presence/heartbeat
```

**请求参数:**
| 参数名 | 类型 | 必填 | 描述 |
|--------|------|------|------|
| employee_id | number | true | 员工ID |
| timestamp | number | true | 时间戳 |
| location | object | false | 位置信息 |

**响应数据:**
| 字段名 | 类型 | 描述 |
|--------|------|------|
| success | boolean | 更新是否成功 |
| status | string | 当前状态 |
| next_heartbeat | number | 下次心跳时间 |

## 6. 服务器架构图

### 6.1 Redis集群架构

```mermaid
graph TD
    A[应用服务器1] --> B[Redis Sentinel 1]
    A --> C[Redis Sentinel 2]
    A --> D[Redis Sentinel 3]
    
    B --> E[Redis Master]
    C --> E
    D --> E
    
    E --> F[Redis Slave 1]
    E --> G[Redis Slave 2]
    
    H[应用服务器2] --> B
    H --> C
    H --> D
    
    I[应用服务器N] --> B
    I --> C
    I --> D
    
    subgraph "Redis集群"
        E
        F
        G
    end
    
    subgraph "哨兵集群"
        B
        C
        D
    end
    
    subgraph "应用集群"
        A
        H
        I
    end
```

### 6.2 应用层架构

```mermaid
graph TD
    A[HTTP请求] --> B[Nginx网关]
    B --> C[负载均衡器]
    C --> D[Express应用实例1]
    C --> E[Express应用实例2]
    C --> F[Express应用实例N]
    
    D --> G[控制器层]
    E --> G
    F --> G
    
    G --> H[服务层]
    H --> I[数据访问层]
    I --> J[(PostgreSQL)]
    I --> K[(Redis)]
    
    subgraph "中间件层"
        L[认证中间件]
        M[日志中间件]
        N[错误处理中间件]
        O[限流中间件]
    end
    
    G --> L
    G --> M
    G --> N
    G --> O
```

### 6.3 Redis缓存数据流架构

```mermaid
sequenceDiagram
    participant C as 客户端
    participant N as Nginx
    participant A as Express应用
    participant S as Redis Sentinel
    participant M as Redis Master
    participant R as Redis Slave
    participant P as PostgreSQL
    participant W as WebSocket
    
    C->>N: HTTP请求
    N->>A: 转发请求
    A->>S: 获取Redis主节点
    S-->>A: 返回Master地址
    A->>M: 检查缓存
    
    alt 缓存命中
        M-->>A: 返回缓存数据
    else 缓存未命中
        A->>P: 查询数据库
        P-->>A: 返回数据
        A->>M: 写入缓存
        M->>R: 同步到从节点
    end
    
    A-->>N: 响应数据
    N-->>C: 返回响应
    
    Note over W: 实时数据推送
    A->>W: 广播更新
    W-->>C: WebSocket推送
    
    Note over M,R: Redis主从同步
    M->>R: 数据复制
```



## 7. 数据模型

### 6.1 数据模型定义

```mermaid
erDiagram
    DEPARTMENTS ||--o{ EMPLOYEES : contains
    DEPARTMENTS ||--o{ WORKSTATIONS : has
    EMPLOYEES ||--o{ WORKSTATION_ASSIGNMENTS : assigned_to
    WORKSTATIONS ||--o{ WORKSTATION_ASSIGNMENTS : assigns
    EMPLOYEES ||--o{ PRESENCE_LOGS : tracks
    USERS ||--|| EMPLOYEES : references
    
    DEPARTMENTS {
        int id PK
        string name
        string code
        string floor
        json map_config
        timestamp created_at
        timestamp updated_at
    }
    
    EMPLOYEES {
        int id PK
        string name
        string email
        string position
        int department_id FK
        string phone
        json metadata
        timestamp created_at
        timestamp updated_at
    }
    
    WORKSTATIONS {
        int id PK
        string code
        int department_id FK
        float x_coordinate
        float y_coordinate
        float width
        float height
        string status
        json config
        timestamp created_at
        timestamp updated_at
    }
    
    WORKSTATION_ASSIGNMENTS {
        int id PK
        int employee_id FK
        int workstation_id FK
        date start_date
        date end_date
        boolean is_active
        timestamp created_at
    }
    
    USERS {
        int id PK
        string username
        string password_hash
        string email
        string role
        int employee_id FK
        timestamp last_login
        timestamp created_at
        timestamp updated_at
    }
    
    PRESENCE_LOGS {
        int id PK
        int employee_id FK
        string status
        timestamp timestamp
        json metadata
    }
```

### 6.2 数据定义语言 (DDL)

#### 部门表 (departments)
```sql
-- 创建部门表
CREATE TABLE departments (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL UNIQUE,
    code VARCHAR(20) NOT NULL UNIQUE,
    floor VARCHAR(10),
    map_config JSONB DEFAULT '{}',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 创建索引
CREATE INDEX idx_departments_name ON departments(name);
CREATE INDEX idx_departments_code ON departments(code);
CREATE INDEX idx_departments_floor ON departments(floor);

-- 初始化数据
INSERT INTO departments (name, code, floor, map_config) VALUES
('技术部', 'TECH', '3F', '{"color": "#3B82F6", "capacity": 50}'),
('产品部', 'PROD', '3F', '{"color": "#10B981", "capacity": 30}'),
('人事部', 'HR', '2F', '{"color": "#F59E0B", "capacity": 20}'),
('运营部', 'OPS', '2F', '{"color": "#EF4444", "capacity": 25}');
```

#### 员工表 (employees)
```sql
-- 创建员工表
CREATE TABLE employees (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    position VARCHAR(100),
    department_id INTEGER REFERENCES departments(id),
    phone VARCHAR(20),
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 创建全文搜索索引
CREATE INDEX idx_employees_search ON employees 
USING gin(to_tsvector('chinese', name || ' ' || COALESCE(position, '') || ' ' || email));

-- 创建复合索引
CREATE INDEX idx_employees_department_name ON employees(department_id, name);
CREATE INDEX idx_employees_email ON employees(email);

-- 初始化数据
INSERT INTO employees (name, email, position, department_id, phone) VALUES
('张三', 'zhang.san@company.com', '高级工程师', 1, '13800138001'),
('李四', 'li.si@company.com', '产品经理', 2, '13800138002'),
('王五', 'wang.wu@company.com', 'HR专员', 3, '13800138003'),
('赵六', 'zhao.liu@company.com', '运营专员', 4, '13800138004');
```

#### 工位表 (workstations)
```sql
-- 创建工位表
CREATE TABLE workstations (
    id SERIAL PRIMARY KEY,
    code VARCHAR(50) NOT NULL UNIQUE,
    department_id INTEGER REFERENCES departments(id),
    x_coordinate FLOAT NOT NULL,
    y_coordinate FLOAT NOT NULL,
    width FLOAT DEFAULT 120,
    height FLOAT DEFAULT 80,
    status VARCHAR(20) DEFAULT 'available' CHECK (status IN ('available', 'occupied', 'maintenance')),
    config JSONB DEFAULT '{}',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 创建索引
CREATE INDEX idx_workstations_department ON workstations(department_id);
CREATE INDEX idx_workstations_status ON workstations(status);
CREATE INDEX idx_workstations_code ON workstations(code);

-- 创建空间索引（如果需要地理查询）
CREATE INDEX idx_workstations_location ON workstations(x_coordinate, y_coordinate);
```

#### 工位分配表 (workstation_assignments)
```sql
-- 创建工位分配表
CREATE TABLE workstation_assignments (
    id SERIAL PRIMARY KEY,
    employee_id INTEGER REFERENCES employees(id),
    workstation_id INTEGER REFERENCES workstations(id),
    start_date DATE NOT NULL DEFAULT CURRENT_DATE,
    end_date DATE,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    -- 确保同一时间一个工位只能分配给一个员工
    CONSTRAINT unique_active_assignment 
        EXCLUDE (workstation_id WITH =) 
        WHERE (is_active = true AND end_date IS NULL)
);

-- 创建索引
CREATE INDEX idx_assignments_employee ON workstation_assignments(employee_id);
CREATE INDEX idx_assignments_workstation ON workstation_assignments(workstation_id);
CREATE INDEX idx_assignments_active ON workstation_assignments(is_active) WHERE is_active = true;
CREATE INDEX idx_assignments_date_range ON workstation_assignments(start_date, end_date);
```

#### 用户表 (users)
```sql
-- 创建用户表
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    role VARCHAR(20) DEFAULT 'employee' CHECK (role IN ('employee', 'admin', 'super_admin')),
    employee_id INTEGER REFERENCES employees(id),
    last_login TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 创建索引
CREATE INDEX idx_users_username ON users(username);
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_employee ON users(employee_id);
CREATE INDEX idx_users_role ON users(role);
```

#### 在岗记录表 (presence_logs)
```sql
-- 创建在岗记录表
CREATE TABLE presence_logs (
    id SERIAL PRIMARY KEY,
    employee_id INTEGER REFERENCES employees(id),
    status VARCHAR(20) NOT NULL CHECK (status IN ('online', 'offline', 'away', 'busy')),
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'
);

-- 创建索引
CREATE INDEX idx_presence_employee_time ON presence_logs(employee_id, timestamp DESC);
CREATE INDEX idx_presence_status ON presence_logs(status);
CREATE INDEX idx_presence_timestamp ON presence_logs(timestamp DESC);

-- 创建分区表（按月分区，用于历史数据管理）
CREATE TABLE presence_logs_y2024m01 PARTITION OF presence_logs
FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');
```

### 6.3 数据库优化配置

#### PostgreSQL配置优化
```sql
-- 设置连接池
ALTER SYSTEM SET max_connections = 200;
ALTER SYSTEM SET shared_buffers = '256MB';
ALTER SYSTEM SET effective_cache_size = '1GB';
ALTER SYSTEM SET work_mem = '4MB';
ALTER SYSTEM SET maintenance_work_mem = '64MB';

-- 启用查询计划缓存
ALTER SYSTEM SET shared_preload_libraries = 'pg_stat_statements';

-- 配置日志
ALTER SYSTEM SET log_statement = 'mod';
ALTER SYSTEM SET log_min_duration_statement = 1000;

-- 重新加载配置
SELECT pg_reload_conf();
```

#### 创建视图和函数
```sql
-- 创建员工搜索视图
CREATE VIEW employees_search_view AS
SELECT 
    e.id,
    e.name,
    e.email,
    e.position,
    d.name as department_name,
    d.code as department_code,
    w.code as workstation_code,
    w.x_coordinate,
    w.y_coordinate,
    CASE 
        WHEN pl.status = 'online' AND pl.timestamp > NOW() - INTERVAL '6 minutes' 
        THEN 'online' 
        ELSE 'offline' 
    END as presence_status
FROM employees e
LEFT JOIN departments d ON e.department_id = d.id
LEFT JOIN workstation_assignments wa ON e.id = wa.employee_id AND wa.is_active = true
LEFT JOIN workstations w ON wa.workstation_id = w.id
LEFT JOIN LATERAL (
    SELECT status, timestamp 
    FROM presence_logs 
    WHERE employee_id = e.id 
    ORDER BY timestamp DESC 
    LIMIT 1
) pl ON true;

-- 创建搜索函数
CREATE OR REPLACE FUNCTION search_employees(search_term TEXT, dept_filter TEXT DEFAULT NULL)
RETURNS TABLE(
    id INTEGER,
    name VARCHAR(100),
    email VARCHAR(255),
    position VARCHAR(100),
    department_name VARCHAR(100),
    workstation_code VARCHAR(50),
    x_coordinate FLOAT,
    y_coordinate FLOAT,
    presence_status TEXT,
    rank REAL
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        esv.id,
        esv.name,
        esv.email,
        esv.position,
        esv.department_name,
        esv.workstation_code,
        esv.x_coordinate,
        esv.y_coordinate,
        esv.presence_status,
        ts_rank(to_tsvector('chinese', esv.name || ' ' || COALESCE(esv.position, '') || ' ' || esv.email), 
                plainto_tsquery('chinese', search_term)) as rank
    FROM employees_search_view esv
    WHERE 
        (dept_filter IS NULL OR esv.department_name = dept_filter)
        AND (
            esv.name ILIKE '%' || search_term || '%'
            OR esv.email ILIKE '%' || search_term || '%'
            OR esv.position ILIKE '%' || search_term || '%'
            OR to_tsvector('chinese', esv.name || ' ' || COALESCE(esv.position, '') || ' ' || esv.email) 
               @@ plainto_tsquery('chinese', search_term)
        )
    ORDER BY rank DESC, esv.name
    LIMIT 50;
END;
$$ LANGUAGE plpgsql;
```

## 7. Git版本控制集成指导

### 7.1 Git工作流程

```mermaid
gitgraph
    commit id: "v2.0.0 基础版本"
    branch feature/postgresql-migration
    checkout feature/postgresql-migration
    commit id: "添加PostgreSQL配置"
    commit id: "数据迁移脚本"
    commit id: "更新API接口"
    checkout main
    merge feature/postgresql-migration
    commit id: "v3.0.0 PostgreSQL版本"
    branch feature/websocket-optimization
    checkout feature/websocket-optimization
    commit id: "WebSocket性能优化"
    commit id: "实时数据推送"
    checkout main
    merge feature/websocket-optimization
    commit id: "v3.1.0 实时通信优化"
```

### 7.2 分支管理策略

- **main分支**: 生产环境代码，只接受经过测试的合并请求
- **develop分支**: 开发环境代码，功能开发的集成分支
- **feature/*分支**: 功能开发分支，从develop分支创建
- **hotfix/*分支**: 紧急修复分支，从main分支创建
- **release/*分支**: 发布准备分支，从develop分支创建

### 7.3 提交规范

```bash
# 功能开发
git commit -m "feat(search): 实现PostgreSQL全文搜索功能"
git commit -m "feat(websocket): 添加实时数据推送"

# 问题修复
git commit -m "fix(auth): 修复JWT令牌过期问题"
git commit -m "fix(database): 解决连接池泄漏问题"

# 性能优化
git commit -m "perf(cache): 优化Redis缓存策略"
git commit -m "perf(query): 优化数据库查询性能"

# 文档更新
git commit -m "docs(api): 更新API接口文档"
git commit -m "docs(deploy): 添加部署指南"

# 重构代码
git commit -m "refactor(auth): 重构认证中间件"
git commit -m "refactor(database): 优化数据访问层"
```

### 7.4 版本标签管理

```bash
# 创建版本标签
git tag -a v3.0.0 -m "PostgreSQL数据库升级版本"
git tag -a v3.1.0 -m "WebSocket实时通信优化版本"

# 推送标签
git push origin --tags

# 查看版本历史
git tag -l "v*" --sort=-version:refname
```

### 7.5 自动化工作流

```yaml
# .github/workflows/ci.yml
name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
    - uses: actions/checkout@v3
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        cache: 'npm'
    
    - name: Install dependencies
      run: npm ci
    
    - name: Run tests
      run: npm test
      env:
        DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test
    
    - name: Build application
      run: npm run build
```

## 8. Redis集群部署配置

### 8.1 Docker Compose Redis集群配置

```yaml
# docker-compose.redis.yml
version: '3.9'

services:
  redis-master:
    image: redis:7-alpine
    container_name: redis-master
    command: >
      redis-server
      --appendonly yes
      --replica-announce-ip redis-master
      --replica-announce-port 6379
    ports:
      - "6379:6379"
    volumes:
      - redis_master_data:/data
      - ./redis/redis.conf:/usr/local/etc/redis/redis.conf
    networks:
      - redis-network
    restart: unless-stopped

  redis-slave-1:
    image: redis:7-alpine
    container_name: redis-slave-1
    command: >
      redis-server
      --appendonly yes
      --replicaof redis-master 6379
      --replica-announce-ip redis-slave-1
      --replica-announce-port 6379
    ports:
      - "6380:6379"
    volumes:
      - redis_slave1_data:/data
    networks:
      - redis-network
    depends_on:
      - redis-master
    restart: unless-stopped

  redis-slave-2:
    image: redis:7-alpine
    container_name: redis-slave-2
    command: >
      redis-server
      --appendonly yes
      --replicaof redis-master 6379
      --replica-announce-ip redis-slave-2
      --replica-announce-port 6379
    ports:
      - "6381:6379"
    volumes:
      - redis_slave2_data:/data
    networks:
      - redis-network
    depends_on:
      - redis-master
    restart: unless-stopped

  redis-sentinel-1:
    image: redis:7-alpine
    container_name: redis-sentinel-1
    command: redis-sentinel /usr/local/etc/redis/sentinel.conf
    ports:
      - "26379:26379"
    volumes:
      - ./redis/sentinel.conf:/usr/local/etc/redis/sentinel.conf
    networks:
      - redis-network
    depends_on:
      - redis-master
    restart: unless-stopped

  redis-sentinel-2:
    image: redis:7-alpine
    container_name: redis-sentinel-2
    command: redis-sentinel /usr/local/etc/redis/sentinel.conf
    ports:
      - "26380:26379"
    volumes:
      - ./redis/sentinel.conf:/usr/local/etc/redis/sentinel.conf
    networks:
      - redis-network
    depends_on:
      - redis-master
    restart: unless-stopped

  redis-sentinel-3:
    image: redis:7-alpine
    container_name: redis-sentinel-3
    command: redis-sentinel /usr/local/etc/redis/sentinel.conf
    ports:
      - "26381:26379"
    volumes:
      - ./redis/sentinel.conf:/usr/local/etc/redis/sentinel.conf
    networks:
      - redis-network
    depends_on:
      - redis-master
    restart: unless-stopped

volumes:
  redis_master_data:
  redis_slave1_data:
  redis_slave2_data:

networks:
  redis-network:
    driver: bridge
```

### 8.2 Redis配置文件

```conf
# redis/redis.conf
bind 0.0.0.0
protected-mode no
port 6379
tcp-backlog 511
timeout 0
tcp-keepalive 300

# 内存配置
maxmemory 2gb
maxmemory-policy allkeys-lru

# 持久化配置
save 900 1
save 300 10
save 60 10000
stop-writes-on-bgsave-error yes
rdbcompression yes
rdbchecksum yes
dbfilename dump.rdb
dir /data

# AOF配置
appendonly yes
appendfilename "appendonly.aof"
appendfsync everysec
no-appendfsync-on-rewrite no
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb

# 日志配置
loglevel notice
logfile ""
```

```conf
# redis/sentinel.conf
port 26379
sentinel monitor mymaster redis-master 6379 2
sentinel down-after-milliseconds mymaster 5000
sentinel parallel-syncs mymaster 1
sentinel failover-timeout mymaster 10000
sentinel deny-scripts-reconfig yes
```

## 9. 部署和监控

### 8.1 Docker容器化部署

```yaml
# docker-compose.yml
version: '3.9'

services:
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
      - ./ssl:/etc/nginx/ssl:ro
    depends_on:
      - web
      - api
    restart: unless-stopped

  web:
    build:
      context: .
      dockerfile: Dockerfile.web
    environment:
      - NODE_ENV=production
    restart: unless-stopped

  api:
    build:
      context: .
      dockerfile: Dockerfile.api
    environment:
      - NODE_ENV=production
      - DATABASE_URL=postgresql://postgres:${POSTGRES_PASSWORD}@postgres:5432/${POSTGRES_DB}
      - REDIS_URL=redis://redis:6379
      - JWT_SECRET=${JWT_SECRET}
    depends_on:
      - postgres
      - redis
    restart: unless-stopped

  postgres:
    image: postgres:15-alpine
    environment:
      - POSTGRES_DB=${POSTGRES_DB}
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./scripts/init.sql:/docker-entrypoint-initdb.d/init.sql
    restart: unless-stopped

  redis:
    image: redis:7-alpine
    command: redis-server --appendonly yes
    volumes:
      - redis_data:/data
    restart: unless-stopped

volumes:
  postgres_data:
  redis_data:
```

### 8.2 监控和日志

```yaml
# 添加监控服务
  prometheus:
    image: prom/prometheus
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
    restart: unless-stopped

  grafana:
    image: grafana/grafana
    ports:
      - "3001:3000"
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=${GRAFANA_PASSWORD}
    volumes:
      - grafana_data:/var/lib/grafana
    restart: unless-stopped
```

---

**文档版本**: v3.0.0  
**最后更新**: 2024-12-19  
**维护团队**: 开发团队  
**审核状态**: 已审核