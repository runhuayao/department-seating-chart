# 部门地图 M1 阶段 用户认证与授权系统设计方案

**版本**: v1.0.0  
**创建日期**: 2024-12-19  
**文档类型**: 技术设计方案  

## 1. 登录问题诊断与解决方案

### 1.1 问题描述
- **问题现象**: 用户通过5173端口使用预设账号(admin/123456)登录时出现错误提示
- **影响范围**: 影响用户正常登录和系统功能使用

### 1.2 问题原因分析

#### 可能原因1: 数据库连接问题
```typescript
// 检查数据库连接状态
const checkDatabaseConnection = async () => {
  try {
    const result = await pool.query('SELECT NOW()');
    console.log('数据库连接正常:', result.rows[0]);
  } catch (error) {
    console.error('数据库连接失败:', error);
  }
};
```

#### 可能原因2: 密码加密不匹配
```typescript
// 密码验证逻辑
const verifyPassword = async (plainPassword: string, hashedPassword: string) => {
  return await bcrypt.compare(plainPassword, hashedPassword);
};
```

#### 可能原因3: 用户表数据不存在
```sql
-- 检查用户数据
SELECT * FROM users WHERE username = 'admin';

-- 如果不存在，插入默认管理员账号
INSERT INTO users (username, password_hash, email, role, created_at) 
VALUES (
  'admin', 
  '$2b$10$encrypted_password_hash', 
  'admin@company.com', 
  'admin', 
  NOW()
);
```

### 1.3 解决方案

#### 步骤1: 验证数据库初始化
```bash
# 执行数据库初始化脚本
psql -U postgres -d department_map -f migrations/001_create_tables.sql
```

#### 步骤2: 重置管理员密码
```typescript
// reset-admin-password.ts
import bcrypt from 'bcrypt';
import { pool } from './config/database';

const resetAdminPassword = async () => {
  const saltRounds = 10;
  const hashedPassword = await bcrypt.hash('123456', saltRounds);
  
  await pool.query(
    'UPDATE users SET password_hash = $1 WHERE username = $2',
    [hashedPassword, 'admin']
  );
  
  console.log('管理员密码重置成功');
};
```

#### 步骤3: 验证登录流程
```typescript
// 完整登录验证流程
const authenticateUser = async (username: string, password: string) => {
  // 1. 查询用户
  const userResult = await pool.query(
    'SELECT * FROM users WHERE username = $1',
    [username]
  );
  
  if (userResult.rows.length === 0) {
    throw new Error('用户不存在');
  }
  
  const user = userResult.rows[0];
  
  // 2. 验证密码
  const isValidPassword = await bcrypt.compare(password, user.password_hash);
  if (!isValidPassword) {
    throw new Error('密码错误');
  }
  
  // 3. 生成JWT令牌
  const token = jwt.sign(
    { userId: user.id, username: user.username, role: user.role },
    process.env.JWT_SECRET,
    { expiresIn: '24h' }
  );
  
  return { user, token };
};
```

## 2. 完整用户注册和登录功能实现

### 2.1 前端登录组件优化

```typescript
// src/components/LoginForm.tsx
import React, { useState } from 'react';
import { useAuth } from '../contexts/AuthContext';

interface LoginFormProps {
  onSuccess?: () => void;
}

const LoginForm: React.FC<LoginFormProps> = ({ onSuccess }) => {
  const [formData, setFormData] = useState({
    username: '',
    password: ''
  });
  const [error, setError] = useState('');
  const [loading, setLoading] = useState(false);
  const { login } = useAuth();

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);
    setError('');

    try {
      await login(formData.username, formData.password);
      onSuccess?.();
    } catch (err) {
      setError(err instanceof Error ? err.message : '登录失败');
    } finally {
      setLoading(false);
    }
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      <div>
        <label className="block text-sm font-medium text-gray-700">
          用户名
        </label>
        <input
          type="text"
          value={formData.username}
          onChange={(e) => setFormData(prev => ({ ...prev, username: e.target.value }))}
          className="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md"
          required
        />
      </div>
      
      <div>
        <label className="block text-sm font-medium text-gray-700">
          密码
        </label>
        <input
          type="password"
          value={formData.password}
          onChange={(e) => setFormData(prev => ({ ...prev, password: e.target.value }))}
          className="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md"
          required
        />
      </div>

      {error && (
        <div className="text-red-600 text-sm">{error}</div>
      )}

      <button
        type="submit"
        disabled={loading}
        className="w-full flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 disabled:opacity-50"
      >
        {loading ? '登录中...' : '登录'}
      </button>
      
      <div className="text-xs text-gray-500 mt-2">
        测试账号: admin / 123456
      </div>
    </form>
  );
};

export default LoginForm;
```

### 2.2 用户注册功能

```typescript
// src/components/RegisterForm.tsx
import React, { useState } from 'react';

interface RegisterFormData {
  username: string;
  email: string;
  password: string;
  confirmPassword: string;
  employeeNumber: string;
  departmentId: number;
}

const RegisterForm: React.FC = () => {
  const [formData, setFormData] = useState<RegisterFormData>({
    username: '',
    email: '',
    password: '',
    confirmPassword: '',
    employeeNumber: '',
    departmentId: 1
  });

  const handleRegister = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (formData.password !== formData.confirmPassword) {
      alert('密码确认不匹配');
      return;
    }

    try {
      const response = await fetch('/api/auth/register', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          username: formData.username,
          email: formData.email,
          password: formData.password,
          employeeNumber: formData.employeeNumber,
          departmentId: formData.departmentId
        })
      });

      if (response.ok) {
        alert('注册成功！请登录');
      } else {
        const error = await response.json();
        alert(error.message || '注册失败');
      }
    } catch (error) {
      console.error('注册错误:', error);
      alert('注册失败，请重试');
    }
  };

  return (
    <form onSubmit={handleRegister} className="space-y-4">
      {/* 表单字段 */}
      <div>
        <label>用户名</label>
        <input
          type="text"
          value={formData.username}
          onChange={(e) => setFormData(prev => ({ ...prev, username: e.target.value }))}
          required
        />
      </div>
      
      <div>
        <label>邮箱</label>
        <input
          type="email"
          value={formData.email}
          onChange={(e) => setFormData(prev => ({ ...prev, email: e.target.value }))}
          required
        />
      </div>
      
      <div>
        <label>密码</label>
        <input
          type="password"
          value={formData.password}
          onChange={(e) => setFormData(prev => ({ ...prev, password: e.target.value }))}
          required
        />
      </div>
      
      <div>
        <label>确认密码</label>
        <input
          type="password"
          value={formData.confirmPassword}
          onChange={(e) => setFormData(prev => ({ ...prev, confirmPassword: e.target.value }))}
          required
        />
      </div>
      
      <button type="submit">注册</button>
    </form>
  );
};
```

### 2.3 后端认证API实现

```typescript
// api/routes/auth.ts
import express from 'express';
import bcrypt from 'bcrypt';
import jwt from 'jsonwebtoken';
import { pool } from '../config/database';

const router = express.Router();

// 用户注册
router.post('/register', async (req, res) => {
  const { username, email, password, employeeNumber, departmentId } = req.body;
  
  try {
    // 检查用户是否已存在
    const existingUser = await pool.query(
      'SELECT id FROM users WHERE username = $1 OR email = $2',
      [username, email]
    );
    
    if (existingUser.rows.length > 0) {
      return res.status(400).json({ message: '用户名或邮箱已存在' });
    }
    
    // 加密密码
    const saltRounds = 10;
    const hashedPassword = await bcrypt.hash(password, saltRounds);
    
    // 创建用户
    const result = await pool.query(
      `INSERT INTO users (username, email, password_hash, employee_number, department_id, role, created_at) 
       VALUES ($1, $2, $3, $4, $5, 'user', NOW()) RETURNING id, username, email`,
      [username, email, hashedPassword, employeeNumber, departmentId]
    );
    
    res.status(201).json({
      message: '注册成功',
      user: result.rows[0]
    });
  } catch (error) {
    console.error('注册错误:', error);
    res.status(500).json({ message: '服务器错误' });
  }
});

// 用户登录
router.post('/login', async (req, res) => {
  const { username, password } = req.body;
  
  try {
    // 查询用户
    const userResult = await pool.query(
      `SELECT u.*, d.name as department_name 
       FROM users u 
       LEFT JOIN departments d ON u.department_id = d.id 
       WHERE u.username = $1`,
      [username]
    );
    
    if (userResult.rows.length === 0) {
      return res.status(401).json({ message: '用户名或密码错误' });
    }
    
    const user = userResult.rows[0];
    
    // 验证密码
    const isValidPassword = await bcrypt.compare(password, user.password_hash);
    if (!isValidPassword) {
      return res.status(401).json({ message: '用户名或密码错误' });
    }
    
    // 生成JWT令牌
    const token = jwt.sign(
      { 
        userId: user.id, 
        username: user.username, 
        role: user.role,
        departmentId: user.department_id
      },
      process.env.JWT_SECRET || 'default-secret',
      { expiresIn: '24h' }
    );
    
    // 更新最后登录时间
    await pool.query(
      'UPDATE users SET last_login = NOW() WHERE id = $1',
      [user.id]
    );
    
    res.json({
      message: '登录成功',
      token,
      user: {
        id: user.id,
        username: user.username,
        email: user.email,
        role: user.role,
        departmentId: user.department_id,
        departmentName: user.department_name
      }
    });
  } catch (error) {
    console.error('登录错误:', error);
    res.status(500).json({ message: '服务器错误' });
  }
});

// 验证令牌
router.get('/verify', async (req, res) => {
  const token = req.headers.authorization?.replace('Bearer ', '');
  
  if (!token) {
    return res.status(401).json({ message: '未提供令牌' });
  }
  
  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'default-secret') as any;
    
    // 查询最新用户信息
    const userResult = await pool.query(
      `SELECT u.*, d.name as department_name 
       FROM users u 
       LEFT JOIN departments d ON u.department_id = d.id 
       WHERE u.id = $1`,
      [decoded.userId]
    );
    
    if (userResult.rows.length === 0) {
      return res.status(401).json({ message: '用户不存在' });
    }
    
    const user = userResult.rows[0];
    res.json({
      user: {
        id: user.id,
        username: user.username,
        email: user.email,
        role: user.role,
        departmentId: user.department_id,
        departmentName: user.department_name
      }
    });
  } catch (error) {
    res.status(401).json({ message: '令牌无效' });
  }
});

export default router;
```

## 3. PostgreSQL数据库权限配置

### 3.1 数据库用户权限设计

```sql
-- 创建应用程序数据库用户
CREATE USER app_user WITH PASSWORD 'secure_password_123';

-- 创建只读用户（用于报表和查询）
CREATE USER readonly_user WITH PASSWORD 'readonly_password_123';

-- 授予应用程序用户基本权限
GRANT CONNECT ON DATABASE department_map TO app_user;
GRANT USAGE ON SCHEMA public TO app_user;

-- 授予表级权限
GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public TO app_user;
GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO app_user;

-- 授予只读用户查询权限
GRANT CONNECT ON DATABASE department_map TO readonly_user;
GRANT USAGE ON SCHEMA public TO readonly_user;
GRANT SELECT ON ALL TABLES IN SCHEMA public TO readonly_user;

-- 为新创建的表自动授权
ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT SELECT, INSERT, UPDATE, DELETE ON TABLES TO app_user;
ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT USAGE, SELECT ON SEQUENCES TO app_user;
ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT SELECT ON TABLES TO readonly_user;
```

### 3.2 行级安全策略（RLS）

```sql
-- 启用行级安全
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE workstations ENABLE ROW LEVEL SECURITY;

-- 用户只能查看和修改自己的信息
CREATE POLICY user_self_access ON users
  FOR ALL TO app_user
  USING (id = current_setting('app.current_user_id')::integer);

-- 管理员可以查看所有用户
CREATE POLICY admin_all_access ON users
  FOR ALL TO app_user
  USING (
    EXISTS (
      SELECT 1 FROM users 
      WHERE id = current_setting('app.current_user_id')::integer 
      AND role = 'admin'
    )
  );

-- 工位访问策略：用户只能查看自己部门的工位
CREATE POLICY department_workstation_access ON workstations
  FOR SELECT TO app_user
  USING (
    department_id IN (
      SELECT department_id FROM users 
      WHERE id = current_setting('app.current_user_id')::integer
    )
  );

-- 工位修改策略：只有管理员和工位负责人可以修改
CREATE POLICY workstation_modify_policy ON workstations
  FOR UPDATE TO app_user
  USING (
    EXISTS (
      SELECT 1 FROM users u
      WHERE u.id = current_setting('app.current_user_id')::integer
      AND (u.role = 'admin' OR u.id = workstations.assigned_user_id)
    )
  );
```

### 3.3 数据库连接配置

```typescript
// config/database.ts
import { Pool } from 'pg';

const pool = new Pool({
  host: process.env.DB_HOST || 'localhost',
  port: parseInt(process.env.DB_PORT || '5432'),
  database: process.env.DB_NAME || 'department_map',
  user: process.env.DB_USER || 'app_user',
  password: process.env.DB_PASSWORD || 'secure_password_123',
  max: 20, // 最大连接数
  idleTimeoutMillis: 30000, // 空闲超时
  connectionTimeoutMillis: 2000, // 连接超时
  ssl: process.env.NODE_ENV === 'production' ? {
    rejectUnauthorized: false
  } : false
});

// 设置应用程序上下文（用于RLS）
export const setUserContext = async (userId: number) => {
  await pool.query('SET app.current_user_id = $1', [userId]);
};

export { pool };
```

## 4. 5173端口授权验证流程设计

### 4.1 授权验证中间件

```typescript
// middleware/auth.ts
import jwt from 'jsonwebtoken';
import { Request, Response, NextFunction } from 'express';
import { pool, setUserContext } from '../config/database';

interface AuthRequest extends Request {
  user?: {
    id: number;
    username: string;
    role: string;
    departmentId: number;
  };
}

// JWT验证中间件
export const authenticateToken = async (
  req: AuthRequest, 
  res: Response, 
  next: NextFunction
) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];

  if (!token) {
    return res.status(401).json({ message: '访问令牌缺失' });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'default-secret') as any;
    
    // 验证用户是否仍然存在且活跃
    const userResult = await pool.query(
      'SELECT id, username, role, department_id, is_active FROM users WHERE id = $1',
      [decoded.userId]
    );
    
    if (userResult.rows.length === 0 || !userResult.rows[0].is_active) {
      return res.status(401).json({ message: '用户不存在或已被禁用' });
    }
    
    const user = userResult.rows[0];
    req.user = {
      id: user.id,
      username: user.username,
      role: user.role,
      departmentId: user.department_id
    };
    
    // 设置数据库用户上下文
    await setUserContext(user.id);
    
    next();
  } catch (error) {
    return res.status(403).json({ message: '令牌无效或已过期' });
  }
};

// 角色权限验证中间件
export const requireRole = (roles: string[]) => {
  return (req: AuthRequest, res: Response, next: NextFunction) => {
    if (!req.user) {
      return res.status(401).json({ message: '未认证' });
    }
    
    if (!roles.includes(req.user.role)) {
      return res.status(403).json({ message: '权限不足' });
    }
    
    next();
  };
};

// 部门权限验证中间件
export const requireDepartmentAccess = (req: AuthRequest, res: Response, next: NextFunction) => {
  const { departmentId } = req.params;
  
  if (!req.user) {
    return res.status(401).json({ message: '未认证' });
  }
  
  // 管理员可以访问所有部门
  if (req.user.role === 'admin') {
    return next();
  }
  
  // 普通用户只能访问自己的部门
  if (req.user.departmentId !== parseInt(departmentId)) {
    return res.status(403).json({ message: '无权访问该部门数据' });
  }
  
  next();
};
```

### 4.2 前端授权状态管理

```typescript
// src/contexts/AuthContext.tsx
import React, { createContext, useContext, useState, useEffect } from 'react';

interface User {
  id: number;
  username: string;
  email: string;
  role: string;
  departmentId: number;
  departmentName: string;
}

interface AuthContextType {
  user: User | null;
  token: string | null;
  login: (username: string, password: string) => Promise<void>;
  logout: () => void;
  isAuthenticated: boolean;
  hasPermission: (permission: string) => boolean;
  canModifyWorkstation: (workstationId: number) => boolean;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [user, setUser] = useState<User | null>(null);
  const [token, setToken] = useState<string | null>(localStorage.getItem('token'));

  const login = async (username: string, password: string) => {
    try {
      const response = await fetch('http://localhost:3000/api/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ username, password })
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.message || '登录失败');
      }

      const data = await response.json();
      setToken(data.token);
      setUser(data.user);
      localStorage.setItem('token', data.token);
    } catch (error) {
      throw error;
    }
  };

  const logout = () => {
    setUser(null);
    setToken(null);
    localStorage.removeItem('token');
  };

  const hasPermission = (permission: string): boolean => {
    if (!user) return false;
    
    const permissions: Record<string, string[]> = {
      'admin': ['read', 'write', 'delete', 'manage_users', 'modify_workstations'],
      'manager': ['read', 'write', 'modify_workstations'],
      'user': ['read']
    };
    
    return permissions[user.role]?.includes(permission) || false;
  };

  const canModifyWorkstation = (workstationId: number): boolean => {
    if (!user) return false;
    
    // 管理员可以修改所有工位
    if (user.role === 'admin') return true;
    
    // 部门经理可以修改本部门工位
    if (user.role === 'manager') return true;
    
    // 普通用户只能修改自己的工位（需要额外查询）
    return false;
  };

  // 验证现有令牌
  useEffect(() => {
    const verifyToken = async () => {
      if (token) {
        try {
          const response = await fetch('http://localhost:3000/api/auth/verify', {
            headers: { 'Authorization': `Bearer ${token}` }
          });
          
          if (response.ok) {
            const data = await response.json();
            setUser(data.user);
          } else {
            logout();
          }
        } catch (error) {
          logout();
        }
      }
    };
    
    verifyToken();
  }, [token]);

  return (
    <AuthContext.Provider value={{
      user,
      token,
      login,
      logout,
      isAuthenticated: !!user,
      hasPermission,
      canModifyWorkstation
    }}>
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};
```

### 4.3 路由保护组件

```typescript
// src/components/ProtectedRoute.tsx
import React from 'react';
import { Navigate } from 'react-router-dom';
import { useAuth } from '../contexts/AuthContext';

interface ProtectedRouteProps {
  children: React.ReactNode;
  requiredPermission?: string;
  requiredRole?: string;
}

const ProtectedRoute: React.FC<ProtectedRouteProps> = ({ 
  children, 
  requiredPermission, 
  requiredRole 
}) => {
  const { isAuthenticated, user, hasPermission } = useAuth();

  if (!isAuthenticated) {
    return <Navigate to="/login" replace />;
  }

  if (requiredRole && user?.role !== requiredRole) {
    return <Navigate to="/unauthorized" replace />;
  }

  if (requiredPermission && !hasPermission(requiredPermission)) {
    return <Navigate to="/unauthorized" replace />;
  }

  return <>{children}</>;
};

export default ProtectedRoute;
```

## 5. 数据传输方案评估

### 5.1 方案对比分析

| 传输方式 | 优势 | 劣势 | 适用场景 | 推荐指数 |
|---------|------|------|----------|----------|
| WebSocket | 实时双向通信、低延迟、支持推送 | 连接管理复杂、服务器资源消耗高 | 实时协作、状态同步 | ⭐⭐⭐⭐⭐ |
| RESTful API | 标准化、缓存友好、无状态 | 无法主动推送、轮询效率低 | 标准CRUD操作 | ⭐⭐⭐⭐ |
| HTTP协议 | 简单易用、广泛支持 | 功能有限、无状态 | 简单数据获取 | ⭐⭐⭐ |

### 5.2 WebSocket实现方案（推荐）

```typescript
// server/websocket.ts
import { WebSocketServer, WebSocket } from 'ws';
import jwt from 'jsonwebtoken';
import { pool } from './config/database';

interface AuthenticatedWebSocket extends WebSocket {
  userId?: number;
  username?: string;
  role?: string;
  departmentId?: number;
}

class WebSocketManager {
  private wss: WebSocketServer;
  private clients: Map<number, AuthenticatedWebSocket> = new Map();
  private departmentClients: Map<number, Set<number>> = new Map();

  constructor(port: number) {
    this.wss = new WebSocketServer({ port });
    this.setupWebSocketServer();
  }

  private setupWebSocketServer() {
    this.wss.on('connection', (ws: AuthenticatedWebSocket, req) => {
      console.log('新的WebSocket连接');

      ws.on('message', async (message) => {
        try {
          const data = JSON.parse(message.toString());
          await this.handleMessage(ws, data);
        } catch (error) {
          console.error('消息处理错误:', error);
          ws.send(JSON.stringify({ type: 'error', message: '消息格式错误' }));
        }
      });

      ws.on('close', () => {
        this.handleDisconnection(ws);
      });

      ws.on('error', (error) => {
        console.error('WebSocket错误:', error);
      });
    });
  }

  private async handleMessage(ws: AuthenticatedWebSocket, data: any) {
    switch (data.type) {
      case 'auth':
        await this.authenticateClient(ws, data.token);
        break;
      
      case 'workstation_update':
        await this.handleWorkstationUpdate(ws, data);
        break;
      
      case 'subscribe_department':
        this.subscribeToDepartment(ws, data.departmentId);
        break;
      
      default:
        ws.send(JSON.stringify({ type: 'error', message: '未知消息类型' }));
    }
  }

  private async authenticateClient(ws: AuthenticatedWebSocket, token: string) {
    try {
      const decoded = jwt.verify(token, process.env.JWT_SECRET || 'default-secret') as any;
      
      const userResult = await pool.query(
        'SELECT id, username, role, department_id FROM users WHERE id = $1 AND is_active = true',
        [decoded.userId]
      );
      
      if (userResult.rows.length === 0) {
        ws.send(JSON.stringify({ type: 'auth_error', message: '用户不存在或已禁用' }));
        ws.close();
        return;
      }
      
      const user = userResult.rows[0];
      ws.userId = user.id;
      ws.username = user.username;
      ws.role = user.role;
      ws.departmentId = user.department_id;
      
      this.clients.set(user.id, ws);
      this.addToDepartmentGroup(user.department_id, user.id);
      
      ws.send(JSON.stringify({ 
        type: 'auth_success', 
        message: '认证成功',
        user: {
          id: user.id,
          username: user.username,
          role: user.role,
          departmentId: user.department_id
        }
      }));
    } catch (error) {
      ws.send(JSON.stringify({ type: 'auth_error', message: '令牌无效' }));
      ws.close();
    }
  }

  private async handleWorkstationUpdate(ws: AuthenticatedWebSocket, data: any) {
    if (!ws.userId) {
      ws.send(JSON.stringify({ type: 'error', message: '未认证' }));
      return;
    }

    try {
      // 验证权限
      const hasPermission = await this.checkWorkstationPermission(ws.userId, data.workstationId);
      if (!hasPermission) {
        ws.send(JSON.stringify({ type: 'error', message: '无权限修改此工位' }));
        return;
      }

      // 更新工位信息
      await pool.query(
        'UPDATE workstations SET status = $1, assigned_user_id = $2, updated_at = NOW() WHERE id = $3',
        [data.status, data.assignedUserId, data.workstationId]
      );

      // 广播更新给相关用户
      this.broadcastTodepartment(ws.departmentId!, {
        type: 'workstation_updated',
        workstationId: data.workstationId,
        status: data.status,
        assignedUserId: data.assignedUserId,
        updatedBy: ws.username
      });

      ws.send(JSON.stringify({ type: 'update_success', message: '工位更新成功' }));
    } catch (error) {
      console.error('工位更新错误:', error);
      ws.send(JSON.stringify({ type: 'error', message: '更新失败' }));
    }
  }

  private async checkWorkstationPermission(userId: number, workstationId: number): Promise<boolean> {
    const result = await pool.query(
      `SELECT u.role, u.department_id, w.department_id as workstation_dept
       FROM users u, workstations w
       WHERE u.id = $1 AND w.id = $2`,
      [userId, workstationId]
    );

    if (result.rows.length === 0) return false;

    const { role, department_id, workstation_dept } = result.rows[0];
    
    // 管理员可以修改所有工位
    if (role === 'admin') return true;
    
    // 用户只能修改自己部门的工位
    return department_id === workstation_dept;
  }

  private addToDepartmentGroup(departmentId: number, userId: number) {
    if (!this.departmentClients.has(departmentId)) {
      this.departmentClients.set(departmentId, new Set());
    }
    this.departmentClients.get(departmentId)!.add(userId);
  }

  private broadcastTodepartment(departmentId: number, message: any) {
    const departmentUsers = this.departmentClients.get(departmentId);
    if (departmentUsers) {
      departmentUsers.forEach(userId => {
        const client = this.clients.get(userId);
        if (client && client.readyState === WebSocket.OPEN) {
          client.send(JSON.stringify(message));
        }
      });
    }
  }

  private handleDisconnection(ws: AuthenticatedWebSocket) {
    if (ws.userId) {
      this.clients.delete(ws.userId);
      
      if (ws.departmentId) {
        const departmentUsers = this.departmentClients.get(ws.departmentId);
        if (departmentUsers) {
          departmentUsers.delete(ws.userId);
          if (departmentUsers.size === 0) {
            this.departmentClients.delete(ws.departmentId);
          }
        }
      }
    }
    console.log('WebSocket连接已断开');
  }
}

// 启动WebSocket服务器
const wsManager = new WebSocketManager(8080);
export default wsManager;
```

### 5.3 前端WebSocket客户端

```typescript
// src/services/websocket.ts
class WebSocketService {
  private ws: WebSocket | null = null;
  private token: string | null = null;
  private reconnectAttempts = 0;
  private maxReconnectAttempts = 5;
  private reconnectInterval = 3000;
  private listeners: Map<string, Function[]> = new Map();

  connect(token: string) {
    this.token = token;
    this.ws = new WebSocket('ws://localhost:8080');

    this.ws.onopen = () => {
      console.log('WebSocket连接已建立');
      this.reconnectAttempts = 0;
      
      // 发送认证信息
      this.send({ type: 'auth', token });
    };

    this.ws.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);
        this.handleMessage(data);
      } catch (error) {
        console.error('消息解析错误:', error);
      }
    };

    this.ws.onclose = () => {
      console.log('WebSocket连接已关闭');
      this.attemptReconnect();
    };

    this.ws.onerror = (error) => {
      console.error('WebSocket错误:', error);
    };
  }

  private handleMessage(data: any) {
    const listeners = this.listeners.get(data.type) || [];
    listeners.forEach(listener => listener(data));
  }

  private attemptReconnect() {
    if (this.reconnectAttempts < this.maxReconnectAttempts && this.token) {
      this.reconnectAttempts++;
      console.log(`尝试重连 (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);
      
      setTimeout(() => {
        this.connect(this.token!);
      }, this.reconnectInterval);
    }
  }

  send(data: any) {
    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify(data));
    }
  }

  on(eventType: string, callback: Function) {
    if (!this.listeners.has(eventType)) {
      this.listeners.set(eventType, []);
    }
    this.listeners.get(eventType)!.push(callback);
  }

  off(eventType: string, callback: Function) {
    const listeners = this.listeners.get(eventType);
    if (listeners) {
      const index = listeners.indexOf(callback);
      if (index > -1) {
        listeners.splice(index, 1);
      }
    }
  }

  updateWorkstation(workstationId: number, status: string, assignedUserId?: number) {
    this.send({
      type: 'workstation_update',
      workstationId,
      status,
      assignedUserId
    });
  }

  subscribeToDepartment(departmentId: number) {
    this.send({
      type: 'subscribe_department',
      departmentId
    });
  }

  disconnect() {
    if (this.ws) {
      this.ws.close();
      this.ws = null;
    }
    this.token = null;
    this.reconnectAttempts = 0;
  }
}

export const websocketService = new WebSocketService();
```

### 5.4 RESTful API备选方案

```typescript
// api/routes/workstations.ts
import express from 'express';
import { authenticateToken, requireDepartmentAccess } from '../middleware/auth';
import { pool } from '../config/database';

const router = express.Router();

// 获取工位列表
router.get('/department/:departmentId', 
  authenticateToken, 
  requireDepartmentAccess, 
  async (req, res) => {
    try {
      const { departmentId } = req.params;
      const { page = 1, limit = 20, status } = req.query;
      
      let query = `
        SELECT w.*, u.username as assigned_username
        FROM workstations w
        LEFT JOIN users u ON w.assigned_user_id = u.id
        WHERE w.department_id = $1
      `;
      
      const params = [departmentId];
      
      if (status) {
        query += ' AND w.status = $2';
        params.push(status as string);
      }
      
      query += ' ORDER BY w.number LIMIT $' + (params.length + 1) + ' OFFSET $' + (params.length + 2);
      params.push(limit as string, ((Number(page) - 1) * Number(limit)).toString());
      
      const result = await pool.query(query, params);
      
      res.json({
        workstations: result.rows,
        pagination: {
          page: Number(page),
          limit: Number(limit),
          total: result.rowCount
        }
      });
    } catch (error) {
      console.error('获取工位列表错误:', error);
      res.status(500).json({ message: '服务器错误' });
    }
  }
);

// 更新工位状态
router.put('/:id', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;
    const { status, assignedUserId } = req.body;
    const userId = (req as any).user.id;
    
    // 检查权限
    const permissionCheck = await pool.query(
      `SELECT w.department_id, u.department_id as user_dept, u.role
       FROM workstations w, users u
       WHERE w.id = $1 AND u.id = $2`,
      [id, userId]
    );
    
    if (permissionCheck.rows.length === 0) {
      return res.status(404).json({ message: '工位不存在' });
    }
    
    const { department_id, user_dept, role } = permissionCheck.rows[0];
    
    if (role !== 'admin' && department_id !== user_dept) {
      return res.status(403).json({ message: '无权限修改此工位' });
    }
    
    // 更新工位
    const result = await pool.query(
      `UPDATE workstations 
       SET status = $1, assigned_user_id = $2, updated_at = NOW()
       WHERE id = $3
       RETURNING *`,
      [status, assignedUserId, id]
    );
    
    if (result.rows.length === 0) {
      return res.status(404).json({ message: '工位不存在' });
    }
    
    res.json({
      message: '工位更新成功',
      workstation: result.rows[0]
    });
  } catch (error) {
    console.error('更新工位错误:', error);
    res.status(500).json({ message: '服务器错误' });
  }
});

export default router;
```

## 6. 工位修改权限控制机制

### 6.1 权限矩阵设计

```typescript
// types/permissions.ts
export interface Permission {
  resource: string;
  action: string;
  condition?: (user: User, resource: any) => boolean;
}

export const PERMISSIONS: Record<string, Permission[]> = {
  admin: [
    { resource: 'workstation', action: 'read' },
    { resource: 'workstation', action: 'write' },
    { resource: 'workstation', action: 'delete' },
    { resource: 'user', action: 'read' },
    { resource: 'user', action: 'write' },
    { resource: 'department', action: 'read' },
    { resource: 'department', action: 'write' }
  ],
  manager: [
    { 
      resource: 'workstation', 
      action: 'read',
      condition: (user, workstation) => user.departmentId === workstation.departmentId
    },
    { 
      resource: 'workstation', 
      action: 'write',
      condition: (user, workstation) => user.departmentId === workstation.departmentId
    },
    { resource: 'user', action: 'read' }
  ],
  user: [
    { 
      resource: 'workstation', 
      action: 'read',
      condition: (user, workstation) => user.departmentId === workstation.departmentId
    },
    { 
      resource: 'workstation', 
      action: 'write',
      condition: (user, workstation) => user.id === workstation.assignedUserId
    }
  ]
};
```

### 6.2 权限检查服务

```typescript
// services/permissionService.ts
import { PERMISSIONS, Permission } from '../types/permissions';
import { pool } from '../config/database';

class PermissionService {
  async checkPermission(
    userId: number, 
    resource: string, 
    action: string, 
    resourceId?: number
  ): Promise<boolean> {
    try {
      // 获取用户信息
      const userResult = await pool.query(
        'SELECT id, role, department_id FROM users WHERE id = $1',
        [userId]
      );
      
      if (userResult.rows.length === 0) return false;
      
      const user = userResult.rows[0];
      const userPermissions = PERMISSIONS[user.role] || [];
      
      // 查找匹配的权限
      const permission = userPermissions.find(p => 
        p.resource === resource && p.action === action
      );
      
      if (!permission) return false;
      
      // 如果有条件检查，需要获取资源信息
      if (permission.condition && resourceId) {
        const resourceData = await this.getResourceData(resource, resourceId);
        if (!resourceData) return false;
        
        return permission.condition(user, resourceData);
      }
      
      return true;
    } catch (error) {
      console.error('权限检查错误:', error);
      return false;
    }
  }
  
  private async getResourceData(resource: string, resourceId: number) {
    switch (resource) {
      case 'workstation':
        const result = await pool.query(
          'SELECT * FROM workstations WHERE id = $1',
          [resourceId]
        );
        return result.rows[0] || null;
      
      default:
        return null;
    }
  }
  
  async getUserPermissions(userId: number): Promise<string[]> {
    const userResult = await pool.query(
      'SELECT role FROM users WHERE id = $1',
      [userId]
    );
    
    if (userResult.rows.length === 0) return [];
    
    const userPermissions = PERMISSIONS[userResult.rows[0].role] || [];
    return userPermissions.map(p => `${p.resource}:${p.action}`);
  }
}

export const permissionService = new PermissionService();
```

### 6.3 前端权限控制组件

```typescript
// src/components/PermissionGate.tsx
import React from 'react';
import { useAuth } from '../contexts/AuthContext';

interface PermissionGateProps {
  children: React.ReactNode;
  permission: string;
  fallback?: React.ReactNode;
  resourceId?: number;
}

const PermissionGate: React.FC<PermissionGateProps> = ({ 
  children, 
  permission, 
  fallback = null,
  resourceId 
}) => {
  const { hasPermission } = useAuth();
  
  if (hasPermission(permission)) {
    return <>{children}</>;
  }
  
  return <>{fallback}</>;
};

export default PermissionGate;

// 使用示例
const WorkstationCard: React.FC<{ workstation: Workstation }> = ({ workstation }) => {
  return (
    <div className="workstation-card">
      <h3>工位 {workstation.number}</h3>
      <p>状态: {workstation.status}</p>
      
      <PermissionGate 
        permission="workstation:write"
        resourceId={workstation.id}
        fallback={<span className="text-gray-500">无编辑权限</span>}
      >
        <button onClick={() => editWorkstation(workstation.id)}>
          编辑工位
        </button>
      </PermissionGate>
    </div>
  );
};
```

## 7. 数据库安全配置和最佳实践

### 7.1 数据库安全配置

```sql
-- postgresql.conf 安全配置
-- 1. 网络安全
listen_addresses = 'localhost'  -- 仅本地连接
port = 5432
max_connections = 100

-- 2. 认证安全
password_encryption = scram-sha-256
ssl = on
ssl_cert_file = 'server.crt'
ssl_key_file = 'server.key'

-- 3. 日志配置
logging_collector = on
log_directory = 'pg_log'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
log_statement = 'mod'  -- 记录所有修改操作
log_min_duration_statement = 1000  -- 记录慢查询

-- pg_hba.conf 访问控制
-- TYPE  DATABASE        USER            ADDRESS                 METHOD
local   all             postgres                                peer
local   all             all                                     md5
host    department_map  app_user        127.0.0.1/32           scram-sha-256
host    department_map  readonly_user   127.0.0.1/32           scram-sha-256
```

### 7.2 数据加密和敏感信息保护

```sql
-- 创建加密扩展
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- 敏感数据加密存储
CREATE TABLE user_sensitive_data (
    user_id INTEGER REFERENCES users(id),
    encrypted_phone VARCHAR(255),
    encrypted_id_card VARCHAR(255),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 插入加密数据
INSERT INTO user_sensitive_data (user_id, encrypted_phone, encrypted_id_card)
VALUES (
    1,
    crypt('13800138000', gen_salt('bf')),
    crypt('110101199001011234', gen_salt('bf'))
);

-- 查询解密数据（需要原始值验证）
SELECT user_id 
FROM user_sensitive_data 
WHERE encrypted_phone = crypt('13800138000', encrypted_phone);
```

### 7.3 数据备份和恢复策略

```bash
#!/bin/bash
# backup.sh - 数据库备份脚本

DB_NAME="department_map"
DB_USER="postgres"
BACKUP_DIR="/var/backups/postgresql"
DATE=$(date +"%Y%m%d_%H%M%S")
BACKUP_FILE="${BACKUP_DIR}/${DB_NAME}_${DATE}.sql"

# 创建备份目录
mkdir -p $BACKUP_DIR

# 执行备份
pg_dump -U $DB_USER -h localhost $DB_NAME > $BACKUP_FILE

# 压缩备份文件
gzip $BACKUP_FILE

# 删除7天前的备份
find $BACKUP_DIR -name "${DB_NAME}_*.sql.gz" -mtime +7 -delete

echo "备份完成: ${BACKUP_FILE}.gz"

# 恢复脚本
# psql -U postgres -d department_map < backup_file.sql
```

### 7.4 监控和审计

```sql
-- 创建审计日志表
CREATE TABLE audit_log (
    id SERIAL PRIMARY KEY,
    table_name VARCHAR(50) NOT NULL,
    operation VARCHAR(10) NOT NULL,
    user_id INTEGER,
    old_values JSONB,
    new_values JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 创建审计触发器函数
CREATE OR REPLACE FUNCTION audit_trigger_function()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'DELETE' THEN
        INSERT INTO audit_log (table_name, operation, user_id, old_values)
        VALUES (TG_TABLE_NAME, TG_OP, 
                COALESCE(current_setting('app.current_user_id', true)::integer, 0),
                row_to_json(OLD));
        RETURN OLD;
    ELSIF TG_OP = 'UPDATE' THEN
        INSERT INTO audit_log (table_name, operation, user_id, old_values, new_values)
        VALUES (TG_TABLE_NAME, TG_OP,
                COALESCE(current_setting('app.current_user_id', true)::integer, 0),
                row_to_json(OLD), row_to_json(NEW));
        RETURN NEW;
    ELSIF TG_OP = 'INSERT' THEN
        INSERT INTO audit_log (table_name, operation, user_id, new_values)
        VALUES (TG_TABLE_NAME, TG_OP,
                COALESCE(current_setting('app.current_user_id', true)::integer, 0),
                row_to_json(NEW));
        RETURN NEW;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- 为关键表添加审计触发器
CREATE TRIGGER workstations_audit_trigger
    AFTER INSERT OR UPDATE OR DELETE ON workstations
    FOR EACH ROW EXECUTE FUNCTION audit_trigger_function();

CREATE TRIGGER users_audit_trigger
    AFTER INSERT OR UPDATE OR DELETE ON users
    FOR EACH ROW EXECUTE FUNCTION audit_trigger_function();
```

## 8. 实施计划和测试方案

### 8.1 实施步骤

1. **数据库配置阶段**（1-2天）
   - 执行数据库权限配置脚本
   - 设置行级安全策略
   - 配置审计日志

2. **后端开发阶段**（3-5天）
   - 实现认证中间件
   - 开发权限检查服务
   - 完善API接口

3. **前端开发阶段**（2-3天）
   - 优化登录组件
   - 实现权限控制组件
   - 集成WebSocket客户端

4. **测试阶段**（2-3天）
   - 单元测试
   - 集成测试
   - 安全测试

### 8.2 测试用例

```typescript
// tests/auth.test.ts
import request from 'supertest';
import { app } from '../src/app';
import { pool } from '../src/config/database';

describe('认证系统测试', () => {
  beforeEach(async () => {
    // 清理测试数据
    await pool.query('DELETE FROM users WHERE username LIKE \'test_%\'');
  });

  describe('用户注册', () => {
    it('应该成功注册新用户', async () => {
      const response = await request(app)
        .post('/api/auth/register')
        .send({
          username: 'test_user',
          email: 'test@example.com',
          password: 'password123',
          employeeNumber: 'EMP001',
          departmentId: 1
        });
      
      expect(response.status).toBe(201);
      expect(response.body.message).toBe('注册成功');
    });

    it('应该拒绝重复用户名', async () => {
      // 先创建一个用户
      await request(app)
        .post('/api/auth/register')
        .send({
          username: 'test_duplicate',
          email: 'test1@example.com',
          password: 'password123',
          employeeNumber: 'EMP002',
          departmentId: 1
        });

      // 尝试创建重复用户名
      const response = await request(app)
        .post('/api/auth/register')
        .send({
          username: 'test_duplicate',
          email: 'test2@example.com',
          password: 'password123',
          employeeNumber: 'EMP003',
          departmentId: 1
        });
      
      expect(response.status).toBe(400);
      expect(response.body.message).toBe('用户名或邮箱已存在');
    });
  });

  describe('用户登录', () => {
    beforeEach(async () => {
      // 创建测试用户
      await request(app)
        .post('/api/auth/register')
        .send({
          username: 'test_login',
          email: 'login@example.com',
          password: 'password123',
          employeeNumber: 'EMP004',
          departmentId: 1
        });
    });

    it('应该成功登录有效用户', async () => {
      const response = await request(app)
        .post('/api/auth/login')
        .send({
          username: 'test_login',
          password: 'password123'
        });
      
      expect(response.status).toBe(200);
      expect(response.body.token).toBeDefined();
      expect(response.body.user.username).toBe('test_login');
    });

    it('应该拒绝错误密码', async () => {
      const response = await request(app)
        .post('/api/auth/login')
        .send({
          username: 'test_login',
          password: 'wrong_password'
        });
      
      expect(response.status).toBe(401);
      expect(response.body.message).toBe('用户名或密码错误');
    });
  });

  describe('权限验证', () => {
    let adminToken: string;
    let userToken: string;

    beforeEach(async () => {
      // 创建管理员用户
      await pool.query(
        `INSERT INTO users (username, email, password_hash, role, department_id) 
         VALUES ('test_admin', 'admin@test.com', '$2b$10$hashedpassword', 'admin', 1)`
      );
      
      // 创建普通用户
      await pool.query(
        `INSERT INTO users (username, email, password_hash, role, department_id) 
         VALUES ('test_user', 'user@test.com', '$2b$10$hashedpassword', 'user', 1)`
      );

      // 获取令牌
      const adminResponse = await request(app)
        .post('/api/auth/login')
        .send({ username: 'test_admin', password: 'password123' });
      adminToken = adminResponse.body.token;

      const userResponse = await request(app)
        .post('/api/auth/login')
        .send({ username: 'test_user', password: 'password123' });
      userToken = userResponse.body.token;
    });

    it('管理员应该能访问所有工位', async () => {
      const response = await request(app)
        .get('/api/workstations/department/1')
        .set('Authorization', `Bearer ${adminToken}`);
      
      expect(response.status).toBe(200);
    });

    it('普通用户应该只能访问自己部门的工位', async () => {
      const response = await request(app)
        .get('/api/workstations/department/2')
        .set('Authorization', `Bearer ${userToken}`);
      
      expect(response.status).toBe(403);
    });
  });
});
```

### 8.3 性能测试

```typescript
// tests/performance.test.ts
import { performance } from 'perf_hooks';
import { pool } from '../src/config/database';
import { permissionService } from '../src/services/permissionService';

describe('性能测试', () => {
  it('权限检查应该在100ms内完成', async () => {
    const start = performance.now();
    
    await permissionService.checkPermission(1, 'workstation', 'read', 1);
    
    const end = performance.now();
    const duration = end - start;
    
    expect(duration).toBeLessThan(100);
  });

  it('数据库查询应该有合理的响应时间', async () => {
    const start = performance.now();
    
    await pool.query(
      `SELECT w.*, u.username 
       FROM workstations w 
       LEFT JOIN users u ON w.assigned_user_id = u.id 
       WHERE w.department_id = $1 
       LIMIT 50`,
      [1]
    );
    
    const end = performance.now();
    const duration = end - start;
    
    expect(duration).toBeLessThan(200);
  });
});
```

## 9. 部署和运维指南

### 9.1 环境变量配置

```bash
# .env.production
NODE_ENV=production
PORT=3000

# 数据库配置
DB_HOST=localhost
DB_PORT=5432
DB_NAME=department_map
DB_USER=app_user
DB_PASSWORD=secure_password_123

# JWT配置
JWT_SECRET=your_super_secret_jwt_key_here
JWT_EXPIRES_IN=24h

# WebSocket配置
WS_PORT=8080

# Redis配置（可选）
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_PASSWORD=redis_password

# 日志配置
LOG_LEVEL=info
LOG_FILE=./logs/app.log
```

### 9.2 Docker部署配置

```dockerfile
# Dockerfile
FROM node:18-alpine

WORKDIR /app

# 复制依赖文件
COPY package*.json ./
RUN npm ci --only=production

# 复制源代码
COPY . .

# 构建应用
RUN npm run build

# 创建非root用户
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nextjs -u 1001

# 设置权限
USER nextjs

EXPOSE 3000 8080

CMD ["npm", "start"]
```

```yaml
# docker-compose.yml
version: '3.8'

services:
  app:
    build: .
    ports:
      - "3000:3000"
      - "8080:8080"
    environment:
      - NODE_ENV=production
      - DB_HOST=postgres
    depends_on:
      - postgres
      - redis
    volumes:
      - ./logs:/app/logs

  postgres:
    image: postgres:15
    environment:
      POSTGRES_DB: department_map
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres_password
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./migrations:/docker-entrypoint-initdb.d
    ports:
      - "5432:5432"

  redis:
    image: redis:7-alpine
    command: redis-server --requirepass redis_password
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

volumes:
  postgres_data:
  redis_data:
```

### 9.3 监控和日志

```typescript
// src/utils/logger.ts
import winston from 'winston';

const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  defaultMeta: { service: 'department-map' },
  transports: [
    new winston.transports.File({ 
      filename: 'logs/error.log', 
      level: 'error' 
    }),
    new winston.transports.File({ 
      filename: 'logs/combined.log' 
    })
  ]
});

if (process.env.NODE_ENV !== 'production') {
  logger.add(new winston.transports.Console({
    format: winston.format.simple()
  }));
}

export default logger;
```

## 10. 总结

本文档提供了完整的用户认证与授权系统设计方案，包括：

1. **登录问题诊断**：分析了admin/123456登录失败的可能原因并提供解决方案
2. **完整认证系统**：实现了用户注册、登录、权限验证的完整流程
3. **数据库安全**：配置了PostgreSQL权限、行级安全策略和审计机制
4. **授权流程**：设计了基于角色的权限控制和资源访问策略
5. **数据传输方案**：评估并推荐了WebSocket作为主要通信方式
6. **权限控制**：实现了细粒度的工位修改权限管理
7. **安全最佳实践**：提供了数据加密、备份、监控等安全措施
8. **测试和部署**：包含了完整的测试用例和部署指南

该方案确保了系统的安全性、可扩展性和可维护性，为部门地图项目提供了坚实的认证授权基础。